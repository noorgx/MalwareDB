import os
import hashlib
import zipfile
import requests
from tqdm import tqdm
from datetime import datetime, timedelta
import concurrent.futures
from concurrent.futures import ProcessPoolExecutor, ThreadPoolExecutor
from termcolor import colored
import time

base = f"https://datalake.abuse.ch/malware-bazaar/daily/"
text = requests.get(base).text
def check(date):
    if isinstance(date, datetime):
        date = date.strftime('%Y-%m-%d')
    if date not in text:
        print(colored(f"Failed to download the file {date}.zip. File may not exist for the specified date.", 'red'))
        return False
    else:
        return True
def download_file(date):
    # Ensure the date is passed in as a string in the correct format
    if isinstance(date, datetime):
        date = date.strftime('%Y-%m-%d')

    filename = f"{date}.zip"
    file_url = f"https://datalake.abuse.ch/malware-bazaar/daily/{filename}"

    max_retries = 100
    retry_delay = 2  # seconds

    for attempt in range(max_retries):
        try:
            if not check(date):
                return
            response = requests.head(file_url, timeout=10)
            if response.status_code != 200:
                print(colored(f"Failed to download the file '{filename}'. {response.status_code}", 'red'))
                return

            total_size = int(response.headers.get('content-length', 0))
            downloaded_size = 0

            response = requests.get(file_url, stream=True, timeout=10)
            with open(filename, 'wb') as file:
                for data in response.iter_content(chunk_size=4096):
                    file.write(data)
                    downloaded_size += len(data)

            print(colored(f"\nFile '{filename}' downloaded successfully.", 'green'))
            return
        except requests.exceptions.RequestException as e:
            print(colored(f"Error downloading {filename}: {e}", 'red'))
            if attempt < max_retries - 1:
                print(colored(f"Retrying in {retry_delay} seconds...", 'yellow'))
                time.sleep(retry_delay)
            else:
                print(colored(f"Failed to download {filename} after {max_retries} attempts.", 'red'))
                return
def download_file_process(date):
    # Ensure the date is passed in as a string in the correct format
    if isinstance(date, datetime):
        date = date.strftime('%Y-%m-%d')

    filename = f"{date}.zip"
    file_url = f"https://datalake.abuse.ch/malware-bazaar/daily/{filename}"

    max_retries = 100
    retry_delay = 2  # seconds

    for attempt in range(max_retries):
        try:
            if not check(date):
                return
            response = requests.head(file_url, timeout=10)
            if response.status_code != 200:
                print(colored(f"Failed to download the file '{filename}'. {response.status_code}", 'red'))
                return

            total_size = int(response.headers.get('content-length', 0))

            response = requests.get(file_url, stream=True, timeout=10)
            with open(filename, 'wb') as file:
                # Read the file in chunks and write to disk
                for data in response.iter_content(chunk_size=4096):
                    file.write(data)

            # print(colored(f"File '{filename}' downloaded successfully.", 'green'))
            return
        except requests.exceptions.RequestException as e:
            print(colored(f"Error downloading {filename}: {e}", 'red'))
            if attempt < max_retries - 1:
                print(colored(f"Retrying in {retry_delay} seconds...", 'yellow'))
                time.sleep(retry_delay)
            else:
                print(colored(f"Failed to download {filename} after {max_retries} attempts.", 'red'))
                return


def download_files_in_range(start_date, end_date):
    total_days = (end_date - start_date).days + 1
    date_list = [(start_date + timedelta(days=i)).strftime("%Y-%m-%d") for i in range(total_days)]

    with ThreadPoolExecutor(max_workers=10) as executor:  # Adjust 'max_workers' as needed
        with tqdm(total=total_days, desc="Downloading Files", unit="day") as progress_bar:
            futures = {executor.submit(download_file, date): date for date in date_list}

            for future in concurrent.futures.as_completed(futures):
                progress_bar.update(1)
                try:
                    future.result()
                except Exception as exc:
                    print(colored(f"Download generated an exception for {futures[future]}: {exc}", 'red'))

def download_all_files():
    current_date = datetime.strptime("2020-02-24", '%Y-%m-%d')
    end_date = datetime.now()

    date_list = []
    while current_date <= end_date:
        if check(current_date):
            date_list.append(current_date)
        current_date += timedelta(days=1)

    total_files = len(date_list)
    print(colored(f"Total files to download: {total_files}", 'blue'))

    # Use ThreadPoolExecutor to download files in parallel
    with concurrent.futures.ThreadPoolExecutor() as executor:

        with tqdm(total=total_files, desc="Downloading Files", unit="file") as pbar:
            # Define a callback function to update the progress bar
            def download_callback(future):
                pbar.update(1)

            futures = {executor.submit(download_file_process, date): date for date in date_list}

            for future in concurrent.futures.as_completed(futures):
                future.add_done_callback(download_callback)  # Attach the callback
                try:
                    future.result()
                except Exception as exc:
                    print(colored(f"Download generated an exception for {futures[future]}: {exc}", 'red'))

# Save file to disk with password protection handling
def unzip_single_file(item, progress_bar=None, password="infected"):
    try:
        with zipfile.ZipFile(item, 'r') as zip_ref:
            try:
                zip_ref.extractall("Downloaded Samples", pwd=password.encode())
                if progress_bar:
                    progress_bar.update(1)
                print(colored(f"Unzipped {item} with default password.", 'green'))
            except RuntimeError as e:
                print(colored(f"Error unzipping {item} with default password: {e}", 'red'))
                new_password = input(colored("Enter the password for the encrypted ZIP file: ", 'yellow')).strip()
                try:
                    zip_ref.extractall("Downloaded Samples", pwd=new_password.encode())
                    if progress_bar:
                        progress_bar.update(1)
                    print(colored(f"Unzipped {item} with user-provided password.", 'green'))
                except RuntimeError as e:
                    print(colored(f"Error unzipping {item} with user-provided password: {e}", 'red'))
                except Exception as e:
                    print(colored(f"Error unzipping {item}: {e}", 'red'))
    except Exception as e:
        print(colored(f"Error unzipping {item}: {e}", 'red'))

# Unzip files from a list of zip files using multithreading
def unzip_files_threaded(zip_files):

    with ThreadPoolExecutor(max_workers=5) as exe:
        with tqdm(total=len(zip_files), desc="Unzipping Files", unit="file") as progress_bar:
            futures = []
            for item in zip_files:
                futures.append(exe.submit(unzip_single_file, item, progress_bar))
            for future in futures:
                future.result()

def unzip_faster(path='.'):
    os.makedirs("Downloaded Samples", exist_ok=True)

    zip_files = [item for item in os.listdir(path) if item.endswith(".zip")]

    # Start the process pool for batch processing
    n_workers = 16 
    with ProcessPoolExecutor(n_workers) as exe:
        with tqdm(total=len(zip_files), desc="Total Unzipping Progress", unit="file") as overall_progress:
            chunk_size = len(zip_files) // n_workers + 1
            futures = []

            for i in range(0, len(zip_files), chunk_size):
                chunk = zip_files[i:i + chunk_size]
                futures.append(exe.submit(unzip_files_threaded, chunk))

            for future in tqdm(futures, total=len(futures), desc="Processing Chunks", unit="chunk"):

                future.result()
                overall_progress.update(len(chunk))

def unzip_files(password="infected"):
    os.makedirs("Downloaded Samples", exist_ok=True)

    zip_files = [item for item in os.listdir() if item.endswith(".zip")]

    with tqdm(total=len(zip_files), desc="Unzipping Files", unit="file") as progress_bar:
        for item in zip_files:
            try:
                with zipfile.ZipFile(item, 'r') as zip_ref:
                    try:
                        zip_ref.extractall("Downloaded Samples", pwd=password.encode())
                        print(colored(f"Unzipped {item} with default password.", 'green'))
                        progress_bar.update(1)
                    except RuntimeError as e:
                        print(colored(f"Error unzipping {item} with default password: {e}", 'red'))
                        new_password = input(colored("Enter the password for the encrypted ZIP files: ", 'yellow')).strip()
                        try:
                            zip_ref.extractall("Downloaded Samples", pwd=new_password.encode())
                            print(colored(f"Unzipped {item} with user-provided password.", 'green'))
                            progress_bar.update(1)
                        except RuntimeError as e:
                            print(colored(f"Error unzipping {item} with user-provided password: {e}", 'red'))
                        except Exception as e:
                            print(colored(f"Error unzipping {item}: {e}", 'red'))
            except Exception as e:
                print(colored(f"Error unzipping {item}: {e}", 'red'))


def calculate_hash(file_path, algorithm):
    hash_func = None
    if algorithm == 'md5':
        hash_func = hashlib.md5()
    elif algorithm == 'sha1':
        hash_func = hashlib.sha1()
    elif algorithm == 'sha2':
        hash_func = hashlib.sha256()

    with open(file_path, 'rb') as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hash_func.update(chunk)

    return hash_func.hexdigest()


def calculate_hashes(algorithm):
    hash_file = f"{algorithm}.txt"
    with open(hash_file, 'w') as f:
        for root, _, files in os.walk("Downloaded Samples"):
            for file in files:
                file_path = os.path.join(root, file)
                try:
                    hash_value = calculate_hash(file_path, algorithm)
                    f.write(f"{hash_value}\n")
                except OSError as e:
                    print(colored(f"Error calculating hash for {file_path}: {e}", 'red'))
    print(colored(f"Hashes calculated and saved in {hash_file}", 'green'))


def calculate_all_hashes():
    for algo in ['md5', 'sha1', 'sha2']:
        calculate_hashes(algo)



def move_and_rename_file(file_path):
    """Calculate sha256 hash of the file, move it to a folder named by the hash, rename it with a .malz extension, and store hashes."""
    try:

        sha256_hash = calculate_hash(file_path, 'sha2')
        hash_folder = os.path.join("Downloaded Samples", sha256_hash)
        os.makedirs(hash_folder, exist_ok=True)
        file_name = os.path.basename(file_path)
        new_file_name = file_name + ".malz"
        new_file_path = os.path.join(hash_folder, new_file_name)
        os.rename(file_path, new_file_path)
        print(colored(f"Moved and renamed {file_name} to {new_file_path}", 'green'))
        for algo in ['md5', 'sha1', 'sha2']:
            hash_value = calculate_hash(new_file_path, algo)
            hash_file_path = os.path.join(hash_folder, f"{algo}.txt")
            with open(hash_file_path, 'w') as f:
                f.write(hash_value)
            print(colored(f"Saved {algo.upper()} hash for {new_file_name} in {hash_file_path}", 'cyan'))

    except OSError as e:
        print(colored(f"Error processing {file_path}: {e}", 'red'))

def process_all_files():
    """Process all files in 'Downloaded Samples' by calculating their hashes, renaming them, and moving them to respective folders."""
    for root, _, files in os.walk("Downloaded Samples"):
        for file in files:
            file_path = os.path.join(root, file)
            if root.startswith("Downloaded Samples/") and len(os.path.basename(root)) == 64:
                continue

            move_and_rename_file(file_path)


def main():
    choice = input(
        colored("Enter 'S' to download a single file or 'M' to download multiple files or 'A' for downlaoding all (maybe one terabyte hard will needed) :) : ", 'yellow')).strip().upper()

    if choice == 'S':
        date = input(colored("Enter the date in YYYY-MM-DD format: ", 'yellow')).strip()
        download_file(date)
    elif choice == 'M':
        start_date_str = input(colored("Enter the start date in YYYY-MM-DD format: ", 'yellow')).strip()
        end_date_str = input(colored("Enter the end date in YYYY-MM-DD format: ", 'yellow')).strip()

        start_date = datetime.strptime(start_date_str, "%Y-%m-%d")
        end_date = datetime.strptime(end_date_str, "%Y-%m-%d")

        download_files_in_range(start_date, end_date)
    elif choice == 'A':
        download_all_files()
    else:
        print(colored("Invalid choice. Please enter 'S' or 'M' or 'A'.", 'red'))
        return

    unzip_choice = input(colored("Do you want to unzip all downloaded files? (Y/N): ", 'yellow')).strip().upper()
    multithreaded = input(colored("Do you want to unzip all downloaded files in multithreaded mode? (Y/N): ", 'yellow')).strip().upper()
    if multithreaded == "Y":
        unzip_faster()
        hash_choice = input(
            colored("Do you want to calculate the hash of each file? (Y/N): ", 'yellow')).strip().upper()
        if hash_choice == 'Y':
            hash_algo_choice = input(
                colored("Enter the hashing algorithm (md5, sha1, sha2, all): ", 'yellow')).strip().lower()
            if hash_algo_choice in ['md5', 'sha1', 'sha2']:
                calculate_hashes(hash_algo_choice)
            elif hash_algo_choice == 'all':
                process_all_files()
            else:
                print(colored("Invalid hashing algorithm choice.", 'red'))
    else:
        if unzip_choice == 'Y':
            unzip_files()
            hash_choice = input(
                colored("Do you want to calculate the hash of each file? (Y/N): ", 'yellow')).strip().upper()
            if hash_choice == 'Y':
                hash_algo_choice = input(
                    colored("Enter the hashing algorithm (md5, sha1, sha2, all): ", 'yellow')).strip().lower()
                if hash_algo_choice in ['md5', 'sha1', 'sha2']:
                    calculate_hashes(hash_algo_choice)
                elif hash_algo_choice == 'all':
                    process_all_files()
                else:
                    print(colored("Invalid hashing algorithm choice.", 'red'))


if __name__ == "__main__":
    main()

